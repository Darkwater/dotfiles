#!/usr/bin/env ruby

Thread.abort_on_exception = true

class Monitor
    @monitors = []
    @monitors_by_name = {}

    def self.add(instance)
        @monitors << instance
        @monitors_by_name[instance.name] = instance
    end

    def self.[](n)
        case n
        when Integer
            @monitors[n]
        when String
            @monitors_by_name[n]
        end
    end

    def self.all
        @monitors
    end

    def self.each
        @monitors.each { |m| yield m }
    end

    def initialize(name, res, pos)
        @name = name
        @res = res.split 'x', 2
        @pos = pos.split '+', 2

        @res.map!(&:to_i)
        @pos.map!(&:to_i)

        @desktops = []

        Monitor.add self

        create_panel
    end

    def create_panel
        @panel ||= Panel.new self
    end

    def active_window
        `bspc query -m "#{name}" -T`
            .lines                          # Split output by lines
            .drop(1)                        # Drop the monitor line
            .slice_before(/^\t\S/)          # Split by desktops
            .select{ |n| n.first[/\*$/] }   # Select the active desktop
            .first                          # Go down to the only active desktop
            .drop(1)                        # Drop the desktop line
            .select{ |n| n[/\*$/] }         # Select the active window
            .first                          # Go down to the only active window
            .split[3]                       # Get the window ID
    end

    attr_accessor :active
    attr_reader :panel, :name, :desktops
    def x; @pos[0] end
    def y; @pos[1] end
    def w; @res[0] end
    def h; @res[1] end

    def to_s
        "Monitor #{@name} #{@res.join 'x'} #{@pos.join '+'}"
    end
end

class Panel
    def initialize(monitor)
        @height = `bspc config -m "#{monitor.name}" bottom_padding`.to_i

        @monitor = monitor
        @bar = open "|lemonbar -g #{monitor.w}x#{@height}+#{monitor.x}+#{monitor.y + monitor.h - @height}" +
                             " -f 'Droid Sans Mono:size=8'" +
                             " -f '-wuncon-siji-medium-r-normal--10-100-75-75-c-80-iso10646-1'" +
                             " -B '#e61d1f21' -o 1", 'w+'
    end

    def update
        draw '  '

        draw @monitor.desktops.map{ |name, color| "%{A:bspc desktop -f #{name}:}%{F#{color}}î„„ %{A}" }.join
        draw ' '
        draw "%{F#efefef}#{`xtitle #{@monitor.active_window}` rescue ''}"

        draw '%{c}'

        draw '%{r}'

        draw Time.now.strftime '%H:%M'

        draw '  '
        @bar.write "\n"
    end

    private

    def draw(stuff)
        @bar.write stuff.gsub "\n", ''
    end
end


`bspc query -T`.scan(/^\S.*$/) do |m|
    /(?<name>\S+) (?<size>\d+x\d+)\+(?<pos>\d+\+\d+)/ =~ m
    Monitor.new name, size, pos
end


threads = []

# Update every second
threads << Thread.new{ loop{ sleep 1; Monitor.each{ |n| n.panel.update } } }

# Desktops
threads << Thread.new do
    bspc = open '|bspc control --subscribe window', 'r'
    bspc.each_line do |line|
        puts line

        case line[0]
        when 'W'
            monitor = nil

            line[1..-1].split(':').each do |item|
                name = item[1..-1]

                case item[0]
                when 'M', 'm'
                    monitor = Monitor[name]
                    monitor.active = item[0] == 'M'
                    monitor.desktops.clear
                when 'L' # layout; end of desktops
                    monitor.panel.update
                else
                    colors = {
                        'O' => '#edeff1', # occupied active
                        'F' => '#5d5f61', # free active
                        'o' => '#7d7f81', # occupied inactive
                        'f' => '#3d3f41', # free inactive
                        'u' => '#ffaf00', # urgent
                        'U' => '#ffaf00'
                    }

                    monitor.desktops << [ name, colors[item[0]] ]
                end
            end
        end
    end
end

sleep
