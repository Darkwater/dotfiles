#!/usr/bin/env ruby
require 'json'

Thread.abort_on_exception = true
Object.send :remove_const, :Monitor # I'll need this tyvm

module Icon
    { "\ue015" => :clock,
      "\ue02e" => :information,
      "\ue214" => :battery,
      "\ue215" => :battery_charging,
      "\ue01b" => :thermal,
      "\ue0fd" => :music,
      "\ue277" => :desktop_occupied,
      "\ue278" => :desktop_free,
      "\ue279" => :separator }
    .each_pair do |char, name|
        define_singleton_method(name) { char }
    end
end

module Color
    { '#101010' => :black,
      '#e84f4f' => :red,
      '#b8d68c' => :green,
      '#e1aa5d' => :yellow,
      '#7dc1cf' => :blue,
      '#9b64fb' => :magenta,
      '#6d878d' => :cyan,
      '#dddddd' => :white }
    .each_pair do |color, name|
        define_singleton_method(name) { color }
    end

    def self.blink(even, odd)
        send (Time.now.to_i.even?) ? even : odd
    end
end

module Util
    def self.threshold(value, thresholds)
        thresholds.to_a.reverse.each do |trip, out|
            return out if value >= trip
        end
    end
end

module Bar
    def self.color(arg = '-')
        "%{F#{arg}}"
    end
end

module Bspc
    def self.tree
        JSON.parse(`bspc query -T`, symbolize_names: true)[:monitors].map do |mobj|
            Monitor.new mobj
        end.sort
    end
end


class JsonObject
    def initialize(obj)
        obj.each_pair do |key, value|
            key = key.to_s.gsub(/[A-Z]/){ |c| "_#{c.downcase}" }.to_sym
            instance_variable_set :"@#{key}", value
            define_singleton_method(key) { instance_variable_get :"@#{key}" } unless respond_to? key
        end
    end
end

class Geometry
    attr_reader :width, :height, :x, :y

    def initialize(obj)
        @width, @height, @x, @y = obj[:width], obj[:height], obj[:x], obj[:y]
    end

    alias left x
    alias top y

    def right; left + width; end
    def bottom; top + height; end

    def area; width * height; end
end

class Padding
    attr_reader :top, :right, :bottom, :left

    def initialize(obj)
        @top, @right, @bottom, @left = obj[:topPadding], mobj[:rightPadding], mobj[:bottomPadding], mobj[:leftPadding]
    end
end

class Monitor < JsonObject
    include Comparable

    attr_reader :order, :geometry

    def initialize(mobj)
        super mobj

        # Turn JSON hashes into Desktops
        @desktops.map! do |dobj|
            Desktop.new dobj, dobj[:name] == focused_desktop_name
        end

        # Rely on N-M desktop naming scheme for the Mth desktop on the Nth screen (1-indexed, eg. 1-2)
        @order = @desktops.first.name[0].to_i - 1

        @geometry = Geometry.new @rectangle
    end

    def <=>(other)
        self.order <=> other.order
    end

    def focused_desktop
        @desktops.find{ |n| n.name == focused_desktop_name }
    end

    def focused_window
        focused_desktop.focused_window
    end

    %i| primary secondary tertiary quaternary quinary senary septenary octonary nonary denary |
    .each_with_index do |name, index|
        name_question = :"#{name}?"

        define_singleton_method(name) { Bspc.tree.find{ |n| n.send name_question } }
        define_singleton_method(name_question) { Bspc.tree.any?{ |n| n.send name_question } }
        define_method(name_question) { @order == index }
    end
end

class Desktop < JsonObject
    attr_reader :windows, :active
    alias active? :active

    def initialize(dobj, active)
        super dobj
        @active = active

        # Walk through desktop tree and collect a list of windows
        pass = [ dobj[:root] ].reject(&:nil?)
        newpass = nil
        @windows = []

        until pass.empty? do
            newpass = []

            pass.each do |node|
                # Only add items if they're not nil
                newpass += [ node[:firstChild], node[:secondChild] ].reject(&:nil?)
                @windows += [ node[:client] ].reject(&:nil?)
            end

            pass = newpass
        end

        @windows.map! do |wobj|
            Window.new wobj
        end
    end

    def focused_window
        @windows.find{ |n| n.window == @focused_window }
    end

    def free?
        @root == nil
    end

    def urgent?
        @windows.any?(&:urgent)
    end

    def fullscreen?
        @windows.any?{ |n| n.state == 'fullscreen' }
    end
end

class Window < JsonObject
end


class Panel
    def initialize(monitor)
        @height = `bspc config -m "#{monitor.name}" bottom_padding`.to_i

        @monitor_name = monitor.name
        @bar = open "|lemonbar -g #{monitor.geometry.width}x#{@height}+#{monitor.geometry.left}" +
                                "+#{monitor.geometry.bottom - @height}" +
                             " -f '-misc-tamsyn-medium-r-normal--14-101-100-100-c-70-iso8859-1'" +
                             " -f '-wuncon-siji-medium-r-normal--10-100-75-75-c-80-iso10646-1'" +
                             " -B '#eb1d1f21'", 'w+'

        @bar_read_thread = Thread.new do
            @bar.each_line{ |n| system n.chomp }
        end

        @drawing = false
    end

    def monitor
        Bspc.tree.find{ |n| n.name == @monitor_name }
    end

    def space(n)
        draw " " * n
    end

    def separator
        draw " \ue279 "
    end

    def align(where)
        draw "%{#{where.to_s[0]}}"
    end

    def desktops
        draw '%{A4:bspc desktop -f prev:}'
        draw '%{A5:bspc desktop -f next:}'

        monitor.desktops.each do |desktop|
            draw "%{A:bspc desktop -f #{desktop.name}:}"

            draw desktop.active? ? "%{F#efefef}"
               : desktop.urgent? ? "%{F#ffaf00}"
                                 : "%{F#707070}"

            draw desktop.free? ? Icon.desktop_free
                               : Icon.desktop_occupied

            draw " %{A}"
        end

        draw '%{A}%{A}'
    end

    def active_window_title(limit_width = false)
        # TODO: Do something about this!?
        #  / 2: show on one half
        #  / 7: font char width
        # - 10: compensate for desktop icons
        max_width = monitor.geometry.width
        max_width = max_width / 2 / 7 - 10 if limit_width
        draw "%{F#efefef}#{`xtitle #{monitor.focused_window.window}`[0..max_width] rescue ''}"
    end

    def time
        icon = Icon.clock
        text = Time.now.strftime('%H:%M')
        color = Util.threshold Time.now.hour,
                 0 => Color.cyan,
                 6 => Color.blue,
                12 => Color.green,
                18 => Color.yellow

        draw_system icon, text, color
    end

    def now_playing
        mpc = `mpc 2>/dev/null`.lines
        draw "#{Icon.music} #{mpc.first}" if mpc[1][/playing/] rescue nil
    end

    def battery
        value = Battery.value
        return if value.nil?

        icon = Battery.charging? ? Icon.battery_charging : Icon.battery
        text = "#{value}%"
        color = Util.threshold value,
                 0 => Color.blink(:red, :white),
                10 => Color.red,
                30 => Color.yellow,
                50 => Color.green

        draw_system icon, text, color
    end

    def thermal
        sensor = Thermal.sensors['coretemp-isa-0000']
        value  = sensor[:temp1_input]
        high   = sensor[:temp1_max] - 15
        max    = sensor[:temp1_max]
        crit   = sensor[:temp1_crit]

        icon  = Icon.thermal
        text  = "#{value} Â°C"
        color = Util.threshold value,
                0    => Color.green,
                high => Color.yellow,
                max  => Color.red,
                crit => Color.blink(:red, :white)

        draw_system icon, text, color
    end

    def update
        return if @drawing

        if monitor.focused_desktop.fullscreen?
            @bar.write "%{B#00000000}\n"
            return
        end

        @drawing = true
        @use_separator = false
        draw '%{B-}'
        space 2

        show_now_playing = `mpc 2>/dev/null`['[playing]'] && monitor.secondary? || !Monitor.secondary?

        desktops
        space 1
        active_window_title(show_now_playing)

        if show_now_playing
            align :center
            space 10

            now_playing

            space 10
        end

        align :right
        space 20

        thermal
        battery
        time

        space 2
        @bar.write "\n"
        @drawing = false
    end

    private

    def draw(stuff)
        @bar.write stuff.gsub "\n", ''
    end

    def draw_system(icon, text, color = '#ffffff')
        return if icon.nil? || text.nil?

        if @use_separator
            separator
        else
            @use_separator = true
        end

        draw "#{Bar.color color}#{icon} #{text}#{Bar.color}"
    end
end


module System
    def update_if_needed
        return if Time.now.to_f - @last_update < @update_interval

        update
        @last_update = Time.now.to_f
    end
end

module Battery
    extend System

    @last_update = 0
    @update_interval = 10

    def self.update
        value = `acpi -b 2>/dev/null`[/([0-9]+)%/, 1]

        if value.nil?
            @update_interval = 360
            @value = nil
        else
            @value = value.to_i
        end
    end

    def self.value
        @value
    end

    def self.charging?
        `acpi -a 2>/dev/null`['off-line'].nil?
    end
end

module Thermal
    extend System

    @last_update = 0
    @update_interval = 10

    def self.update
        raw = `sensors -uA`
        chips = raw.lines.map(&:chomp).slice_after('')
        @sensors = chips.map do |chip|
            name = chip.first
            values = chip.map do |line|
                /^  (?<key>[a-z0-9_]+): (?<value>[0-9.,]+)/ =~ line
                [ key.to_sym, value.to_f ] if $~
            end.reject(&:nil?).to_h

            [ name, values ]
        end.to_h
    end

    def self.sensors
        @sensors
    end
end

systems = [ Battery, Thermal ]
systems.each(&:update)


panels = []

Bspc.tree.each do |monitor|
    panels << Panel.new(monitor)
end


threads = []

# Update panels every second
threads << Thread.new{ loop{ panels.each(&:update); sleep 1 } }

# Update panels on desktop switch
threads << Thread.new do
    bspc = open '|bspc control --subscribe', 'r'
    bspc.each_line do panels.each(&:update) end
end

# Update systems whenever needed
threads << Thread.new{ loop{ systems.each(&:update_if_needed); sleep 1 } }

sleep
