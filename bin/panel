#!/usr/bin/env ruby
require 'json'

Thread.abort_on_exception = true
Object.send :remove_const, :Monitor # I'll need this tyvm

module Icon
    { "\ue02e" => :information,
      "\ue214" => :battery,
      "\ue01b" => :thermal,
      "\ue0fd" => :headphones,
      "\ue0fe" => :music_note,
      "\ue277" => :desktop_occupied,
      "\ue278" => :desktop_free,
      "\ue279" => :separator }
    .each_pair do |char, name|
        define_singleton_method(name) { char }
    end
end

module Bspc
    def self.tree
        JSON.parse(`bspc query -T`, symbolize_names: true)[:monitors].map do |mobj|
            Monitor.new mobj
        end.sort
    end
end

class JsonObject
    def initialize(obj)
        obj.each_pair do |key, value|
            key = key.to_s.gsub(/[A-Z]/){ |c| "_#{c.downcase}" }.to_sym
            instance_variable_set :"@#{key}", value
            define_singleton_method(key) { instance_variable_get :"@#{key}" } unless respond_to? key
        end
    end
end

class Geometry
    attr_reader :width, :height, :x, :y

    def initialize(obj)
        @width, @height, @x, @y = obj[:width], obj[:height], obj[:x], obj[:y]
    end

    alias left x
    alias top y

    def right; left + width; end
    def bottom; top + height; end

    def area; width * height; end
end

class Padding
    attr_reader :top, :right, :bottom, :left

    def initialize(obj)
        @top, @right, @bottom, @left = obj[:topPadding], mobj[:rightPadding], mobj[:bottomPadding], mobj[:leftPadding]
    end
end

class Monitor < JsonObject
    include Comparable

    attr_reader :order, :geometry

    def initialize(mobj)
        super mobj

        # Turn JSON hashes into Desktops
        @desktops.map! do |dobj|
            Desktop.new dobj, dobj[:name] == focused_desktop_name
        end

        # Rely on N-M desktop naming scheme for the Mth desktop on the Nth screen (1-indexed, eg. 1-2)
        @order = @desktops.first.name[0].to_i - 1

        @geometry = Geometry.new @rectangle
    end

    def <=>(other)
        self.order <=> other.order
    end

    def focused_desktop
        @desktops.find{ |n| n.name == focused_desktop_name }
    end

    def focused_window
        focused_desktop.focused_window
    end

    %i| primary secondary tertiary quaternary quinary senary septenary octonary nonary denary |
    .each_with_index do |name, index|
        name_question = :"#{name}?"

        define_singleton_method(name) { Bspc.tree.find{ |n| n.send name_question } }
        define_singleton_method(name_question) { Bspc.tree.any?{ |n| n.send name_question } }
        define_method(name_question) { @order == index }
    end
end

class Desktop < JsonObject
    attr_reader :windows, :active
    alias active? :active

    def initialize(dobj, active)
        super dobj
        @active = active

        # Walk through desktop tree and collect a list of windows
        pass = [ dobj[:root] ].reject(&:nil?)
        newpass = nil
        @windows = []

        until pass.empty? do
            newpass = []

            pass.each do |node|
                # Only add items if they're not nil
                newpass += [ node[:firstChild], node[:secondChild] ].reject(&:nil?)
                @windows += [ node[:client] ].reject(&:nil?)
            end

            pass = newpass
        end

        @windows.map! do |wobj|
            Window.new wobj
        end
    end

    def focused_window
        @windows.find{ |n| n.window == @focused_window }
    end

    def free?
        @root == nil
    end

    def urgent?
        @windows.any?{ |n| n.urgent }
    end
end

class Window < JsonObject
end

module Notifications
    @notifications = []

    def self.run
        @statnot = open '|statnot /dev/stdin', 'r+'
        @statnot.puts <<-EOF.gsub(/^ {12}/, '') # please python :<
            import sys
            MAX_NOTIFY_TIMEOUT = 1
            DEFAULT_NOTIFY_TIMEOUT = 1
            USE_STATUSTEXT = False
            def update_text(text):
                print(text)
                sys.stdout.flush()
        EOF
        @statnot.close_write

        Thread.new do
            @statnot.each_line do |n|
                push Notification.new(*n.chomp.split(' ', 2))
                Monitor.primary.panel.update
            end
        end

        Thread.new do
            loop do
                sleep 1

                next if last.nil?

                last.timeout -= 1
                if last.timeout <= 0
                    pop
                end
            end
        end
    end

    def self.method_missing(*args)
        @notifications.send(*args)
    end
end

class Panel
    def initialize(monitor)
        @height = `bspc config -m "#{monitor.name}" bottom_padding`.to_i

        @monitor_name = monitor.name
        @bar = open "|lemonbar -g #{monitor.geometry.width}x#{@height}+#{monitor.geometry.left}" +
                                "+#{monitor.geometry.bottom - @height}" +
                             " -f '-misc-tamsyn-medium-r-normal--14-101-100-100-c-70-iso8859-1'" +
                             " -f '-wuncon-siji-medium-r-normal--10-100-75-75-c-80-iso10646-1'" +
                             " -B '#e61d1f21'", 'w+'

        @bar_read_thread = Thread.new do
            @bar.each_line{ |n| system n.chomp }
        end

        @drawing = false
    end

    def monitor
        Bspc.tree.find{ |n| n.name == @monitor_name }
    end

    def space(n)
        draw " " * n
    end

    def separator
        draw " \ue279 "
    end

    def align(where)
        draw "%{#{where.to_s[0]}}"
    end

    def desktops
        draw '%{A4:bspc desktop -f prev:}'
        draw '%{A5:bspc desktop -f next:}'

        monitor.desktops.each do |desktop|
            draw "%{A:bspc desktop -f #{desktop.name}:}"

            draw desktop.active? ? "%{F#efefef}"
               : desktop.urgent? ? "%{F#ffaf00}"
                                 : "%{F#707070}"

            draw desktop.free? ? Icon.desktop_free
                               : Icon.desktop_occupied

            draw " %{A}"
        end

        draw '%{A}%{A}'
    end

    def active_window_title
        draw "%{F#efefef}#{`xtitle #{monitor.focused_window.window}`[0..70] rescue ''}"
    end

    def time
        draw Time.now.strftime '%H:%M'
    end

    def notifications
        draw Notifications.last.render rescue nil
    end

    def now_playing
        mpc = `mpc 2>/dev/null`.lines
        draw "#{Icon.headphones} #{mpc.first}" if mpc[1][/playing/] rescue nil
    end

    def battery
        text = `acpi -b 2>/dev/null`[/[0-9]+%/]
        draw "#{Icon.battery} #{text}" unless text.nil?
    end

    def thermal
        draw "\ue01b #{Thermal.value} Â°C"
    end

    def update
        return if @drawing
        @drawing = true
        space 2

        desktops
        space 1
        active_window_title

        align :center
        space 5

        notifications if monitor.primary?
        now_playing if monitor.secondary? || (!Monitor.secondary? && Notifications.empty?)

        space 5
        align :right

        thermal && separator
        battery && separator
        time

        space 2
        @bar.write "\n"
        @drawing = false
    end

    private

    def draw(stuff)
        @bar.write stuff.gsub "\n", ''
    end
end


module System
    def update_if_needed
        return if Time.now.to_f - @last_update < @update_interval

        update
        @last_update = Time.now.to_f
    end
end

module Thermal
    extend System

    @last_update = 0
    @update_interval = 1

    def self.update
        @value = `sensors -u`.lines.grep(/temp1_input/)[1][/temp1_input: (\d+)/, 1]
    end

    def self.value
        @value
    end
end


systems = [ Thermal ]


panels = []

Bspc.tree.each do |monitor|
    panels << Panel.new(monitor)
end


threads = []

# Update panels every second
threads << Thread.new{ loop{ panels.each(&:update); sleep 1 } }

# Update panels on desktop switch
threads << Thread.new do
    bspc = open '|bspc control --subscribe', 'r'
    bspc.each_line do panels.each(&:update) end
end

# Update systems whenever needed
threads << Thread.new{ loop{ systems.each(&:update_if_needed); sleep 1 } }

sleep
